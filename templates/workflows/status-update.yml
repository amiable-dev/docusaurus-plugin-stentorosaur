name: Status Update

on:
  schedule:
    # Runs every hour to keep status page fresh
    - cron: '0 * * * *'
  workflow_dispatch:
  issues:
    types: [opened, closed, labeled, unlabeled, edited]

permissions:
  contents: write  # Required to commit status data changes
  issues: read     # Required to fetch status issues

jobs:
  update-status:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
          
      - name: Update status data
        env:
          # Must explicitly pass token to make it available in process.env
          # secrets.GITHUB_TOKEN exists but is NOT in process.env unless you pass it via env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx stentorosaur-update-status
        
      # Status data is now updated in build/status-data/ directory
      # Commit changes to trigger deployment
      
      - name: Get status changes
        id: status
        run: |
          if [ -d "build/status-data" ]; then
            # Stage files to detect both tracked changes AND untracked files
            # Use --force since build/ is gitignored (but build/status-data/ is excepted)
            git add --force build/status-data/
            
            # Check if there are staged changes (works for new files too)
            if ! git diff --staged --quiet; then
              # Read summary to generate commit message
              if [ -f "build/status-data/summary.json" ]; then
                # Extract system statuses and generate emoji message
                SYSTEMS_UP=$(jq -r '[.[] | select(.status == "up") | .name] | join(", ")' build/status-data/summary.json 2>/dev/null || echo "")
                SYSTEMS_DOWN=$(jq -r '[.[] | select(.status == "down") | .name] | join(", ")' build/status-data/summary.json 2>/dev/null || echo "")
                SYSTEMS_DEGRADED=$(jq -r '[.[] | select(.status == "degraded") | .name] | join(", ")' build/status-data/summary.json 2>/dev/null || echo "")
                
                # Build commit message with emojis
                MSG="ðŸ“Š Update status data"
                if [ -n "$SYSTEMS_DOWN" ]; then
                  MSG="ðŸŸ¥ Systems down: $SYSTEMS_DOWN"
                elif [ -n "$SYSTEMS_DEGRADED" ]; then
                  MSG="ðŸŸ¨ Systems degraded: $SYSTEMS_DEGRADED"
                elif [ -n "$SYSTEMS_UP" ]; then
                  MSG="ðŸŸ© All systems operational"
                fi
                
                echo "commit_message=$MSG" >> $GITHUB_OUTPUT
                echo "has_changes=true" >> $GITHUB_OUTPUT
              else
                echo "commit_message=ðŸ“Š Update status data" >> $GITHUB_OUTPUT
                echo "has_changes=true" >> $GITHUB_OUTPUT
              fi
            else
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Commit updated status data
        if: steps.status.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add build/status-data/
          git commit -m "${{ steps.status.outputs.commit_message }} [skip ci]"
          git push
