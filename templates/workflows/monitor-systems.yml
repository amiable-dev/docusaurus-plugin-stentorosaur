name: Monitor Systems

on:
  schedule:
    # Runs every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  issues: write
  contents: write  # Required to commit response time data

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        # Define systems/endpoints to monitor
        # This should be customized based on your needs
        system: 
          - name: 'api'
            url: 'https://api.example.com/health'
          - name: 'website'
            url: 'https://example.com'
          - name: 'database'
            url: 'https://db.example.com/status'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Check ${{ matrix.system.name }} status
        id: check
        continue-on-error: true
        run: |
          npx stentorosaur-monitor \
            --system "${{ matrix.system.name }}" \
            --url "${{ matrix.system.url }}" \
            --output-dir build/status-data
          
      - name: Commit response time data
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            
            // Configure git
            execSync('git config user.name "github-actions[bot]"');
            execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
            
            // Check if there are changes
            const status = execSync('git status --porcelain build/status-data/').toString();
            
            if (status) {
              const commitMessage = '${{ steps.check.outputs.commit_message }}' || 'Update status data [skip ci]';
              
              execSync('git add build/status-data/');
              execSync(`git commit -m "${commitMessage}"`);
              execSync('git push origin HEAD:${{ github.ref_name }}');
            }
          
      - name: Create issue for downtime
        if: steps.check.outputs.status == 'down'
        uses: actions/github-script@v7
        with:
          script: |
            const systemName = '${{ matrix.system.name }}';
            const statusCode = '${{ steps.check.outputs.status_code }}';
            
            // Check if there's already an open automated issue for this system
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['status', systemName, 'automated'],
              state: 'open'
            });
            
            if (issues.data.length === 0) {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `${systemName} is down`,
                body: `## Incident Report
                
                **System:** ${systemName}
                **Status:** Down
                **HTTP Status Code:** ${statusCode}
                **Time:** ${new Date().toISOString()}
                **URL:** ${{ matrix.system.url }}
                
                The system is currently experiencing issues and is not responding as expected.
                
                ---
                *This issue was automatically created by the monitoring workflow.*`,
                labels: ['status', systemName, 'critical', 'automated']
              });
            }
            
      - name: Close issue for recovery
        if: steps.check.outputs.status == 'up'
        uses: actions/github-script@v7
        with:
          script: |
            const systemName = '${{ matrix.system.name }}';
            
            // Find open automated issues for this system (only auto-created downtime issues)
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['status', systemName, 'automated'],
              state: 'open'
            });
            
            // Close them with a recovery comment
            for (const issue of issues.data) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## âœ… Resolved
                
                The system has recovered and is now operational.
                
                **Time:** ${new Date().toISOString()}
                
                ---
                *This update was automatically posted by the monitoring workflow.*`
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });
            }
