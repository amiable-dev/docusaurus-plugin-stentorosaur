name: Monitor Systems

on:
  schedule:
    # Runs every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  issues: write
  contents: write  # Required to commit response time data

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Monitor all systems
        id: check
        continue-on-error: true
        run: |
          # Clear npm cache to ensure we always get the latest plugin version
          npm cache clean --force
          
          # Monitor all systems defined in .monitorrc.json
          # This runs sequentially to avoid race conditions and ensure zero data loss
          npx -y -p @amiable-dev/docusaurus-plugin-stentorosaur stentorosaur-monitor \
            --config .monitorrc.json \
            --verbose
          
      - name: Commit response time data
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            
            // Configure git
            execSync('git config user.name "github-actions[bot]"');
            execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
            
            // Check if there are changes
            const status = execSync('git status --porcelain status-data/').toString();
            
            if (status) {
              execSync('git add status-data/');
              execSync('git commit -m "Update monitoring data [skip ci]"');
              
              // Simple push with retry (no race conditions since single job)
              let retries = 3;
              let delay = 1000;
              
              while (retries > 0) {
                try {
                  execSync('git pull --rebase origin ${{ github.ref_name }}');
                  execSync('git push origin HEAD:${{ github.ref_name }}');
                  console.log('Successfully pushed changes');
                  break;
                } catch (error) {
                  retries--;
                  
                  if (retries === 0) {
                    console.error('Failed to push after 3 attempts');
                    throw error;
                  }
                  console.log(`Push failed, retrying in ${delay}ms...`);
                  execSync(`sleep ${delay / 1000}`);
                  delay *= 2;
                }
              }
            } else {
              console.log('No changes to commit');
            }
          
      - name: Manage downtime issues
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Load monitoring config to get system list
            const config = JSON.parse(fs.readFileSync('.monitorrc.json', 'utf8'));

            // Load maintenance data to check for active maintenance windows
            let maintenanceData = [];
            const maintenancePath = 'status-data/maintenance.json';
            if (fs.existsSync(maintenancePath)) {
              try {
                maintenanceData = JSON.parse(fs.readFileSync(maintenancePath, 'utf8'));
                console.log(`Loaded ${maintenanceData.length} maintenance window(s)`);
              } catch (error) {
                console.log('No maintenance data found or error reading:', error.message);
              }
            }

            // Helper function to check if system is in maintenance
            function isInMaintenance(systemName) {
              for (const maintenance of maintenanceData) {
                if (maintenance.status === 'in-progress' &&
                    maintenance.affectedSystems &&
                    maintenance.affectedSystems.includes(systemName)) {
                  return { inMaintenance: true, maintenance };
                }
              }
              return { inMaintenance: false };
            }

            // Parse current.json to get latest status for each system
            const currentData = JSON.parse(fs.readFileSync('status-data/current.json', 'utf8'));

            // Get latest reading for each system
            const latestBySystem = {};
            for (const reading of currentData) {
              if (!latestBySystem[reading.svc] || reading.t > latestBySystem[reading.svc].t) {
                latestBySystem[reading.svc] = reading;
              }
            }

            // Check each configured system
            for (const systemConfig of config.systems) {
              const systemName = systemConfig.system;
              const latest = latestBySystem[systemName];

              if (!latest) continue;

              const isDown = latest.state === 'down';
              const maintenanceCheck = isInMaintenance(systemName);

              // Find existing automated issues for this system
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['status', systemName, 'automated'],
                state: 'open'
              });

              if (isDown && issues.data.length === 0) {
                // Skip creating incident if system is in maintenance
                if (maintenanceCheck.inMaintenance) {
                  console.log(`⏸️  Skipping incident creation for ${systemName} - in maintenance: ${maintenanceCheck.maintenance.title}`);
                  continue;
                }

                // Create downtime issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `${systemName} is down`,
                  body: `## Incident Report
                  
                  **System:** ${systemName}
                  **Status:** Down
                  **HTTP Status Code:** ${latest.code}
                  **Time:** ${new Date(latest.t).toISOString()}
                  **URL:** ${systemConfig.url}
                  ${latest.err ? `**Error:** ${latest.err}` : ''}
                  
                  The system is currently experiencing issues and is not responding as expected.
                  
                  ---
                  *This issue was automatically created by the monitoring workflow.*`,
                  labels: ['status', systemName, 'critical', 'automated']
                });
              } else if (!isDown && issues.data.length > 0) {
                // Close recovery issues
                for (const issue of issues.data) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `## ✅ Resolved
                    
                    The system has recovered and is now operational.
                    
                    **Time:** ${new Date(latest.t).toISOString()}
                    **Response Time:** ${latest.lat}ms
                    
                    ---
                    *This update was automatically posted by the monitoring workflow.*`
                  });
                  
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });
                }
              }
            }
