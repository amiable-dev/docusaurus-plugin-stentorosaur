name: Monitor Systems

# IMPORTANT: This workflow writes to the 'status-data' orphaned branch
#
# Prerequisites:
#   Run once to create the orphaned branch:
#   npm run setup-status-branch
#
# The 'status-data' branch is isolated from 'main' to keep the repository lean.
# This pattern is used by Upptime and recommended for monitoring data storage.

on:
  schedule:
    # Runs every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  issues: write
  contents: write  # Required to commit response time data

jobs:
  monitor:
    runs-on: ubuntu-latest

    steps:
      # Checkout main branch for scripts and config
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          path: main

      # Checkout status-data branch for data storage
      - name: Checkout status-data branch
        uses: actions/checkout@v4
        with:
          ref: status-data
          path: status-data
          fetch-depth: 1  # Shallow clone for speed

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Monitor all systems
        id: check
        continue-on-error: true
        working-directory: main
        run: |
          # Clear npm cache to ensure we always get the latest plugin version
          npm cache clean --force

          # Monitor all systems defined in .monitorrc.json
          # Output directory points to status-data branch checkout
          npx -y -p @amiable-dev/docusaurus-plugin-stentorosaur stentorosaur-monitor \
            --config .monitorrc.json \
            --output-dir ../status-data \
            --verbose
        env:
          STATUS_DATA_DIR: ../status-data

      - name: Commit status data
        working-directory: status-data
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Stage only monitoring data (current.json and archives)
          # DO NOT stage incidents.json or maintenance.json - those are managed by status-update.yml
          git add current.json archives/ 2>/dev/null || true

          # Commit with timestamp
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          git commit -m "üìä Update monitoring data: $TIMESTAMP" || echo "Nothing to commit"

          # Push with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=2

          for i in $(seq 1 $MAX_RETRIES); do
            if git push origin status-data; then
              echo "‚úÖ Successfully pushed changes"
              exit 0
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Push failed, retrying in ${RETRY_DELAY}s... (attempt $i/$MAX_RETRIES)"
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                git pull --rebase origin status-data
              else
                echo "‚ùå Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
      - name: Manage downtime issues
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Load monitoring config from main branch
            const config = JSON.parse(fs.readFileSync('main/.monitorrc.json', 'utf8'));

            // Load maintenance data from status-data branch
            let maintenanceData = [];
            const maintenancePath = 'status-data/maintenance.json';
            if (fs.existsSync(maintenancePath)) {
              try {
                maintenanceData = JSON.parse(fs.readFileSync(maintenancePath, 'utf8'));
                console.log(`Loaded ${maintenanceData.length} maintenance window(s)`);
              } catch (error) {
                console.log('No maintenance data found or error reading:', error.message);
              }
            }

            // Helper function to check if system is in maintenance
            function isInMaintenance(systemName) {
              for (const maintenance of maintenanceData) {
                if (maintenance.status === 'in-progress' &&
                    maintenance.affectedSystems &&
                    maintenance.affectedSystems.includes(systemName)) {
                  return { inMaintenance: true, maintenance };
                }
              }
              return { inMaintenance: false };
            }

            // Parse current.json from status-data branch
            const currentData = JSON.parse(fs.readFileSync('status-data/current.json', 'utf8'));

            // Get latest reading for each system
            const latestBySystem = {};
            for (const reading of currentData) {
              if (!latestBySystem[reading.svc] || reading.t > latestBySystem[reading.svc].t) {
                latestBySystem[reading.svc] = reading;
              }
            }

            // Check each configured system
            for (const systemConfig of config.systems) {
              const systemName = systemConfig.system;
              const latest = latestBySystem[systemName];

              if (!latest) continue;

              const isDown = latest.state === 'down';
              const maintenanceCheck = isInMaintenance(systemName);

              // Find existing automated issues for this system
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['status', systemName, 'automated'],
                state: 'open'
              });

              if (isDown && issues.data.length === 0) {
                // Skip creating incident if system is in maintenance
                if (maintenanceCheck.inMaintenance) {
                  console.log(`‚è∏Ô∏è  Skipping incident creation for ${systemName} - in maintenance: ${maintenanceCheck.maintenance.title}`);
                  continue;
                }

                // Create downtime issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `${systemName} is down`,
                  body: `## Incident Report
                  
                  **System:** ${systemName}
                  **Status:** Down
                  **HTTP Status Code:** ${latest.code}
                  **Time:** ${new Date(latest.t).toISOString()}
                  **URL:** ${systemConfig.url}
                  ${latest.err ? `**Error:** ${latest.err}` : ''}
                  
                  The system is currently experiencing issues and is not responding as expected.
                  
                  ---
                  *This issue was automatically created by the monitoring workflow.*`,
                  labels: ['status', systemName, 'critical', 'automated']
                });
              } else if (!isDown && issues.data.length > 0) {
                // Close recovery issues
                for (const issue of issues.data) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `## ‚úÖ Resolved
                    
                    The system has recovered and is now operational.
                    
                    **Time:** ${new Date(latest.t).toISOString()}
                    **Response Time:** ${latest.lat}ms
                    
                    ---
                    *This update was automatically posted by the monitoring workflow.*`
                  });
                  
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });
                }
              }
            }

      - name: Send notifications
        if: always()
        continue-on-error: true
        working-directory: main
        run: |
          # Check if notification config exists
          if [ ! -f .notifyrc.json ]; then
            echo "‚è≠Ô∏è  No .notifyrc.json found, skipping notifications"
            exit 0
          fi

          # Check if events file exists (created by monitor script)
          if [ ! -f ../status-data/events.json ]; then
            echo "‚è≠Ô∏è  No events to notify about"
            exit 0
          fi

          # Send notifications for monitoring events
          npx -y -p @amiable-dev/docusaurus-plugin-stentorosaur stentorosaur-notify \
            --config .notifyrc.json \
            --events ../status-data/events.json \
            --verbose || echo "‚ö†Ô∏è  Notifications failed (non-blocking)"
        env:
          # Pass secrets as environment variables (resolved via env:VAR_NAME in config)
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
