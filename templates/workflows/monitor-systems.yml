name: Status Monitor

# CONSOLIDATED WORKFLOW: Health checks + Incident sync + Notifications
#
# This single workflow replaces:
#   - monitor-systems.yml (health checks)
#   - status-update.yml (incident/maintenance sync)
#
# Prerequisites:
#   Run once to create the orphaned branch:
#   npm run setup-status-branch
#
# The 'status-data' branch is isolated from 'main' to keep the repository lean.

on:
  schedule:
    # Run every 5 minutes for health checks
    - cron: '*/5 * * * *'
  workflow_dispatch:
  issues:
    # Respond to issue events for immediate incident updates
    types: [opened, closed, labeled, unlabeled, edited]

permissions:
  issues: write
  contents: write

concurrency:
  group: status-monitor
  cancel-in-progress: false  # Don't cancel running checks

jobs:
  monitor:
    runs-on: ubuntu-latest

    steps:
      # Checkout main branch for scripts and config
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          path: main

      # Checkout status-data branch for data storage
      - name: Checkout status-data branch
        uses: actions/checkout@v4
        with:
          ref: status-data
          path: status-data
          fetch-depth: 1  # Shallow clone for speed

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: main/package-lock.json

      # Install dependencies (only needed for stentorosaur-update-status)
      - name: Install dependencies
        working-directory: main
        run: npm ci

      # STEP 1: Health checks (only on schedule/manual trigger, not on issue events)
      - name: Monitor all systems
        id: check
        if: github.event_name != 'issues'
        continue-on-error: true
        working-directory: main
        run: |
          # Monitor all systems defined in .monitorrc.json
          npx stentorosaur-monitor \
            --config .monitorrc.json \
            --output-dir ../status-data \
            --verbose
        env:
          STATUS_DATA_DIR: ../status-data

      # STEP 2: Update incidents and maintenance from GitHub issues
      - name: Update incidents and maintenance
        working-directory: main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          npx stentorosaur-update-status \
            --write-incidents \
            --write-maintenance \
            --verbose \
            --output-dir ../status-data

      # STEP 3: Commit all status data changes
      - name: Commit status data
        working-directory: status-data
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Stage all status data files
          git add current.json archives/ incidents.json maintenance.json 2>/dev/null || true

          # Commit with timestamp
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          git commit -m "üìä Update status data: $TIMESTAMP" || echo "Nothing to commit"

          # Push with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=2

          for i in $(seq 1 $MAX_RETRIES); do
            if git push origin status-data; then
              echo "‚úÖ Successfully pushed changes"
              exit 0
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Push failed, retrying in ${RETRY_DELAY}s... (attempt $i/$MAX_RETRIES)"
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                git pull --rebase origin status-data
              else
                echo "‚ùå Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      # STEP 4: Manage downtime issues (only on schedule, not on issue events)
      - name: Manage downtime issues
        if: github.event_name != 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Load monitoring config from main branch
            const config = JSON.parse(fs.readFileSync('main/.monitorrc.json', 'utf8'));

            // Load maintenance data from status-data branch
            let maintenanceData = [];
            const maintenancePath = 'status-data/maintenance.json';
            if (fs.existsSync(maintenancePath)) {
              try {
                maintenanceData = JSON.parse(fs.readFileSync(maintenancePath, 'utf8'));
                console.log(`Loaded ${maintenanceData.length} maintenance window(s)`);
              } catch (error) {
                console.log('No maintenance data found or error reading:', error.message);
              }
            }

            // Helper function to check if system is in maintenance
            function isInMaintenance(systemName) {
              for (const maintenance of maintenanceData) {
                if (maintenance.status === 'in-progress' &&
                    maintenance.affectedSystems &&
                    maintenance.affectedSystems.includes(systemName)) {
                  return { inMaintenance: true, maintenance };
                }
              }
              return { inMaintenance: false };
            }

            // Parse current.json from status-data branch
            let currentData = [];
            try {
              currentData = JSON.parse(fs.readFileSync('status-data/current.json', 'utf8'));
            } catch (error) {
              console.log('No current.json found, skipping issue management');
              return;
            }

            // Get latest reading for each system
            const latestBySystem = {};
            for (const reading of currentData) {
              if (!latestBySystem[reading.svc] || reading.t > latestBySystem[reading.svc].t) {
                latestBySystem[reading.svc] = reading;
              }
            }

            // Check each configured system
            for (const systemConfig of config.systems) {
              const systemName = systemConfig.system;
              const latest = latestBySystem[systemName];

              if (!latest) continue;

              const isDown = latest.state === 'down';
              const maintenanceCheck = isInMaintenance(systemName);

              // Find existing automated issues for this system
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['status', systemName, 'automated'],
                state: 'open'
              });

              if (isDown && issues.data.length === 0) {
                // Skip creating incident if system is in maintenance
                if (maintenanceCheck.inMaintenance) {
                  console.log(`‚è∏Ô∏è  Skipping incident creation for ${systemName} - in maintenance: ${maintenanceCheck.maintenance.title}`);
                  continue;
                }

                // Create downtime issue
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `${systemName} is down`,
                  body: [
                    '## Incident Report',
                    '',
                    `**System:** ${systemName}`,
                    '**Status:** Down',
                    `**HTTP Status Code:** ${latest.code}`,
                    `**Time:** ${new Date(latest.t).toISOString()}`,
                    `**URL:** ${systemConfig.url}`,
                    latest.err ? `**Error:** ${latest.err}` : '',
                    '',
                    'The system is currently experiencing issues and is not responding as expected.',
                    '',
                    '---',
                    '*This issue was automatically created by the monitoring workflow.*'
                  ].filter(Boolean).join('\n'),
                  labels: ['status', systemName, 'critical', 'automated']
                });
              } else if (!isDown && issues.data.length > 0) {
                // Close recovery issues
                for (const issue of issues.data) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: [
                      '## ‚úÖ Resolved',
                      '',
                      'The system has recovered and is now operational.',
                      '',
                      `**Time:** ${new Date(latest.t).toISOString()}`,
                      `**Response Time:** ${latest.lat}ms`,
                      '',
                      '---',
                      '*This update was automatically posted by the monitoring workflow.*'
                    ].join('\n')
                  });

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });
                }
              }
            }

      # STEP 5: Generate notification events (on issue events only)
      - name: Generate notification events
        id: generate-events
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const issue = context.payload.issue;
            const action = context.payload.action;

            // Skip if not a status issue
            if (!issue.labels.some(l => l.name === 'status')) {
              console.log('Not a status issue, skipping');
              return;
            }

            const severity = issue.labels.find(l => ['critical', 'major', 'minor'].includes(l.name))?.name || 'minor';
            const affectedEntities = issue.labels
              .filter(l => !['status', 'critical', 'major', 'minor', 'maintenance', 'automated'].includes(l.name))
              .map(l => l.name.replace(/^(system:|process:)/, ''));

            let event = null;

            if (issue.labels.some(l => l.name === 'maintenance')) {
              if (action === 'opened' || action === 'labeled') {
                event = { type: 'maintenance.scheduled', timestamp: new Date().toISOString(), maintenance: { id: issue.number, title: issue.title, affectedEntities, url: issue.html_url } };
              } else if (action === 'closed') {
                event = { type: 'maintenance.completed', timestamp: new Date().toISOString(), maintenance: { id: issue.number, title: issue.title, affectedEntities, url: issue.html_url } };
              }
            } else {
              if (action === 'opened') {
                event = { type: 'incident.opened', timestamp: new Date().toISOString(), incident: { id: issue.number, title: issue.title, severity, affectedEntities, url: issue.html_url } };
              } else if (action === 'closed') {
                event = { type: 'incident.closed', timestamp: new Date().toISOString(), incident: { id: issue.number, title: issue.title, affectedEntities, url: issue.html_url } };
              } else if (action === 'labeled' || action === 'unlabeled' || action === 'edited') {
                event = { type: 'incident.updated', timestamp: new Date().toISOString(), incident: { id: issue.number, title: issue.title, severity, affectedEntities, url: issue.html_url } };
              }
            }

            if (event) {
              fs.writeFileSync('status-data/events.json', JSON.stringify(event, null, 2));
              console.log('Generated event:', event.type);
            }

      # STEP 6: Send notifications
      - name: Send notifications
        if: always()
        continue-on-error: true
        working-directory: main
        run: |
          if [ ! -f .notifyrc.json ]; then
            echo "‚è≠Ô∏è  No .notifyrc.json found, skipping notifications"
            exit 0
          fi

          if [ ! -f ../status-data/events.json ]; then
            echo "‚è≠Ô∏è  No events to notify about"
            exit 0
          fi

          npx stentorosaur-notify \
            --config .notifyrc.json \
            --events ../status-data/events.json \
            --verbose || echo "‚ö†Ô∏è  Notifications failed (non-blocking)"
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_TO: ${{ secrets.EMAIL_TO }}

      # STEP 7: Trigger deployment for critical incidents
      - name: Trigger deployment for critical issues
        if: github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'critical')
        uses: peter-evans/repository-dispatch@v3
        with:
          event-type: status-updated
          token: ${{ secrets.GITHUB_TOKEN }}
