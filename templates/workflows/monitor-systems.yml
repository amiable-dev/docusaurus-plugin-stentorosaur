name: Monitor Systems

on:
  schedule:
    # Runs every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  issues: write
  contents: write  # Required to commit response time data

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        # Define systems/endpoints to monitor
        # This should be customized based on your needs
        system: 
          - name: 'api'
            url: 'https://api.example.com/health'
          - name: 'website'
            url: 'https://example.com'
          - name: 'database'
            url: 'https://db.example.com/status'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Check ${{ matrix.system.name }} status
        id: check
        continue-on-error: true
        run: |
          # Capture both response time and status code
          # time_total is in seconds with decimal precision (e.g., 0.145)
          response=$(curl -s -o /dev/null -w "%{http_code}\n%{time_total}" -m 10 "${{ matrix.system.url }}")
          status_code=$(echo "$response" | head -n1)
          time_seconds=$(echo "$response" | tail -n1)
          
          # Convert seconds to milliseconds (e.g., 0.145 -> 145)
          response_time=$(echo "$time_seconds * 1000" | bc | cut -d. -f1)
          
          echo "status_code=$status_code" >> $GITHUB_OUTPUT
          echo "response_time=$response_time" >> $GITHUB_OUTPUT
          
          if [ "$status_code" -eq 200 ] || [ "$status_code" -eq 301 ] || [ "$status_code" -eq 302 ]; then
            echo "status=up" >> $GITHUB_OUTPUT
          else
            echo "status=down" >> $GITHUB_OUTPUT
          fi
      
      - name: Save response time data
        run: |
          # Create systems directory if it doesn't exist
          mkdir -p build/status-data/systems
          
          # Generate system file name (lowercase, replace spaces with dashes)
          SYSTEM_FILE="build/status-data/systems/${{ matrix.system.name }}.json"
          
          # Read existing data or create new structure
          if [ -f "$SYSTEM_FILE" ]; then
            # Append to existing history (keep last 50 entries)
            cat "$SYSTEM_FILE" | jq --arg time "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg status "${{ steps.check.outputs.status }}" \
              --argjson code "${{ steps.check.outputs.status_code }}" \
              --argjson ms "${{ steps.check.outputs.response_time }}" \
              '.history = ([{timestamp: $time, status: $status, code: $code, responseTime: $ms}] + .history) | .history = .history[:50] | .lastChecked = $time | .currentStatus = $status' > "$SYSTEM_FILE.tmp"
            mv "$SYSTEM_FILE.tmp" "$SYSTEM_FILE"
          else
            # Create new file
            jq -n --arg name "${{ matrix.system.name }}" \
              --arg url "${{ matrix.system.url }}" \
              --arg time "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg status "${{ steps.check.outputs.status }}" \
              --argjson code "${{ steps.check.outputs.status_code }}" \
              --argjson ms "${{ steps.check.outputs.response_time }}" \
              '{name: $name, url: $url, lastChecked: $time, currentStatus: $status, history: [{timestamp: $time, status: $status, code: $code, responseTime: $ms}]}' > "$SYSTEM_FILE"
          fi
          
      - name: Commit response time data
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            
            // Configure git
            execSync('git config user.name "github-actions[bot]"');
            execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
            
            // Check if there are changes
            const status = execSync('git status --porcelain build/status-data/').toString();
            
            if (status) {
              const systemName = '${{ matrix.system.name }}';
              const responseTime = '${{ steps.check.outputs.response_time }}';
              const statusCode = '${{ steps.check.outputs.status_code }}';
              const isUp = '${{ steps.check.outputs.status }}' === 'up';
              
              // Generate emoji commit message
              const emoji = isUp ? 'ðŸŸ©' : 'ðŸŸ¥';
              const message = isUp 
                ? `${emoji} ${systemName} is up (${statusCode} in ${responseTime} ms) [skip ci]`
                : `${emoji} ${systemName} is down (${statusCode}) [skip ci]`;
              
              execSync('git add build/status-data/');
              execSync(`git commit -m "${message}"`);
              execSync('git push origin HEAD:${{ github.ref_name }}');
            }
          
      - name: Create issue for downtime
        if: steps.check.outputs.status == 'down'
        uses: actions/github-script@v7
        with:
          script: |
            const systemName = '${{ matrix.system.name }}';
            const statusCode = '${{ steps.check.outputs.status_code }}';
            
            // Check if there's already an open automated issue for this system
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['status', systemName, 'automated'],
              state: 'open'
            });
            
            if (issues.data.length === 0) {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `${systemName} is down`,
                body: `## Incident Report
                
                **System:** ${systemName}
                **Status:** Down
                **HTTP Status Code:** ${statusCode}
                **Time:** ${new Date().toISOString()}
                **URL:** ${{ matrix.system.url }}
                
                The system is currently experiencing issues and is not responding as expected.
                
                ---
                *This issue was automatically created by the monitoring workflow.*`,
                labels: ['status', systemName, 'critical', 'automated']
              });
            }
            
      - name: Close issue for recovery
        if: steps.check.outputs.status == 'up'
        uses: actions/github-script@v7
        with:
          script: |
            const systemName = '${{ matrix.system.name }}';
            
            // Find open automated issues for this system (only auto-created downtime issues)
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['status', systemName, 'automated'],
              state: 'open'
            });
            
            // Close them with a recovery comment
            for (const issue of issues.data) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## âœ… Resolved
                
                The system has recovered and is now operational.
                
                **Time:** ${new Date().toISOString()}
                
                ---
                *This update was automatically posted by the monitoring workflow.*`
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });
            }
