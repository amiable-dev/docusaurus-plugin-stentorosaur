#!/usr/bin/env node
/**
 * Copyright (c) Your Organization
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Setup script for initializing the orphaned status-data branch
 *
 * This script creates a clean orphaned branch with no shared history with main,
 * following the Upptime pattern for status data storage.
 *
 * Usage:
 *   node scripts/setup-status-branch.js [--force]
 *
 * Options:
 *   --force  Delete existing status-data branch and recreate
 */

const { execSync } = require('child_process');
const fs = require('fs-extra');
const path = require('path');

const BRANCH_NAME = 'status-data';
const README_CONTENT = `# Status Data Branch

This orphaned branch stores runtime monitoring data generated by
[@amiable-dev/docusaurus-plugin-stentorosaur](https://github.com/amiable-dev/docusaurus-plugin-stentorosaur).

**‚ö†Ô∏è Do not merge this branch into main.**

## Structure

\`\`\`
status-data/
‚îú‚îÄ‚îÄ current.json           # Latest readings from all systems
‚îú‚îÄ‚îÄ incidents.json         # Incident history
‚îú‚îÄ‚îÄ maintenance.json       # Scheduled maintenance windows
‚îî‚îÄ‚îÄ archives/
    ‚îî‚îÄ‚îÄ YYYY/MM/           # Historical data organized by year/month
        ‚îî‚îÄ‚îÄ system-name/   # Per-system archives
\`\`\`

## About Orphaned Branches

This branch has no shared history with the main branch, which provides several benefits:

- **Repository size**: Main branch stays lean (faster clones, checkouts)
- **History clarity**: Status commits don't pollute code history
- **Performance**: Main branch operations remain fast as data grows
- **Data retention**: Easy to manage and prune old monitoring data

## Automated Updates

This branch is automatically updated by GitHub Actions workflows:
- \`monitor-systems.yml\` - Runs system health checks and commits status updates
- \`status-update.yml\` - Updates status data from GitHub Issues

## Manual Operations

To work with this branch locally:

\`\`\`bash
# Clone only this branch (fast, no main branch history)
git clone --single-branch --branch status-data https://github.com/YOUR-ORG/YOUR-REPO.git

# Or checkout if you already have the repo
git fetch origin status-data
git checkout status-data
\`\`\`

---

*Generated by @amiable-dev/docusaurus-plugin-stentorosaur v0.6.3+*
`;

function exec(command, options = {}) {
  try {
    return execSync(command, { encoding: 'utf8', stdio: 'pipe', ...options });
  } catch (error) {
    throw new Error(`Command failed: ${command}\n${error.message}`);
  }
}

function checkGitRepo() {
  try {
    exec('git rev-parse --is-inside-work-tree');
    return true;
  } catch (error) {
    return false;
  }
}

function branchExists(branchName) {
  try {
    exec(`git rev-parse --verify ${branchName}`);
    return true;
  } catch (error) {
    return false;
  }
}

function remoteBranchExists(branchName) {
  try {
    exec(`git ls-remote --heads origin ${branchName}`);
    const output = exec(`git ls-remote --heads origin ${branchName}`).trim();
    return output.length > 0;
  } catch (error) {
    return false;
  }
}

function getCurrentBranch() {
  try {
    return exec('git branch --show-current').trim();
  } catch (error) {
    return null;
  }
}

async function setupOrphanedBranch(force = false) {
  console.log('üöÄ Setting up orphaned status-data branch...\n');

  // Step 1: Check if we're in a git repository
  if (!checkGitRepo()) {
    throw new Error('Not in a git repository. Please run this script from your repository root.');
  }

  // Step 2: Check if branch already exists
  const localExists = branchExists(BRANCH_NAME);
  const remoteExists = remoteBranchExists(BRANCH_NAME);

  if ((localExists || remoteExists) && !force) {
    console.log(`‚ùå Branch '${BRANCH_NAME}' already exists.`);
    console.log(`   Use --force flag to delete and recreate.`);
    console.log(`   Or run: git checkout ${BRANCH_NAME}\n`);
    process.exit(1);
  }

  if (force && (localExists || remoteExists)) {
    console.log(`üóëÔ∏è  Deleting existing '${BRANCH_NAME}' branch...`);
    if (localExists) {
      exec(`git branch -D ${BRANCH_NAME}`);
      console.log(`   ‚úÖ Deleted local branch`);
    }
    if (remoteExists) {
      exec(`git push origin --delete ${BRANCH_NAME}`);
      console.log(`   ‚úÖ Deleted remote branch\n`);
    }
  }

  // Step 3: Save current branch
  const currentBranch = getCurrentBranch() || 'main';
  console.log(`üìå Current branch: ${currentBranch}\n`);

  // Step 4: Create orphaned branch
  console.log(`üìù Creating orphaned branch '${BRANCH_NAME}'...`);
  exec(`git checkout --orphan ${BRANCH_NAME}`);
  console.log(`   ‚úÖ Branch created\n`);

  // Step 5: Remove all files from staging
  console.log(`üßπ Cleaning staging area...`);
  try {
    exec('git rm -rf .');
  } catch (error) {
    // It's okay if there are no files to remove
  }
  console.log(`   ‚úÖ Staging area cleaned\n`);

  // Step 6: Create initial structure
  console.log(`üìÅ Creating initial directory structure...`);
  await fs.ensureDir('archives');
  console.log(`   ‚úÖ Created archives/ directory\n`);

  // Step 7: Write README
  console.log(`üìÑ Writing README.md...`);
  await fs.writeFile('README.md', README_CONTENT);
  console.log(`   ‚úÖ README.md created\n`);

  // Step 8: Create initial .gitignore
  console.log(`üö´ Creating .gitignore...`);
  const gitignore = `# macOS
.DS_Store

# Editor directories and files
.idea/
.vscode/
*.swp
*.swo
*~

# Temporary files
*.tmp
.temp/
`;
  await fs.writeFile('.gitignore', gitignore);
  console.log(`   ‚úÖ .gitignore created\n`);

  // Step 9: Commit initial structure
  console.log(`üíæ Creating initial commit...`);
  exec('git add README.md .gitignore archives/');
  exec('git commit -m "Initialize status-data orphaned branch"');
  console.log(`   ‚úÖ Initial commit created\n`);

  // Step 10: Push to remote
  console.log(`‚òÅÔ∏è  Pushing to origin...`);
  try {
    exec(`git push -u origin ${BRANCH_NAME}`);
    console.log(`   ‚úÖ Pushed to origin/${BRANCH_NAME}\n`);
  } catch (error) {
    console.log(`   ‚ö†Ô∏è  Could not push to remote (${error.message})`);
    console.log(`   You can push manually later with: git push -u origin ${BRANCH_NAME}\n`);
  }

  // Step 11: Return to original branch
  console.log(`üîô Returning to ${currentBranch}...`);
  exec(`git checkout ${currentBranch}`);
  console.log(`   ‚úÖ Checked out ${currentBranch}\n`);

  // Step 12: Success message
  console.log(`‚ú® Success! Orphaned branch '${BRANCH_NAME}' is ready.\n`);
  console.log(`Next steps:`);
  console.log(`  1. Update your workflows to use 'ref: ${BRANCH_NAME}'`);
  console.log(`  2. Run migration script if you have existing status data:`);
  console.log(`     node scripts/migrate-to-status-branch.js\n`);
  console.log(`To view the branch:`);
  console.log(`  git checkout ${BRANCH_NAME}\n`);
}

// Main execution
const args = process.argv.slice(2);
const force = args.includes('--force');

setupOrphanedBranch(force)
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error(`\n‚ùå Error: ${error.message}\n`);
    process.exit(1);
  });
